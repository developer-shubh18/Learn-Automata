import Foundation

let unit1Content = UnitContent(
    theory: [
        Topic(title: "1. Introduction to Automata Theory", content: "Automata theory is the study of abstract machines and automata, as well as the computational problems that can be solved using them. It is a fundamental concept in theoretical computer science, compiler design, and artificial intelligence.\n\nThe word 'Automata' is the plural of 'Automaton', which means something that works automatically. An automaton is defined by its states and the transitions between these states based on inputs.\n\nKey Terminology:\n- Symbol (Σ): An abstract entity (e.g., a, b, 0, 1).\n- Alphabet: A finite, non-empty set of symbols.\n- String: A finite sequence of symbols chosen from an alphabet.\n- Language: A set of strings chosen from some Σ*, where Σ* is the set of all possible strings."),
        Topic(title: "2. Deterministic Finite Automata (DFA)", content: "A Deterministic Finite Automaton (DFA) is a finite state machine that accepts or rejects strings of symbols and only produces a unique computation (or run) of the automaton for each input string.\n\nA DFA is represented by a 5-tuple: (Q, Σ, δ, q0, F)\n1. Q: A finite set of states\n2. Σ: A finite set of input symbols (alphabet)\n3. δ: A transition function (δ: Q × Σ -> Q)\n4. q0: An initial or start state (q0 ∈ Q)\n5. F: A set of accept or final states (F ⊆ Q)\n\n'Deterministic' means that for every state and input symbol, there is exactly one guaranteed next state."),
        Topic(title: "3. Non-Deterministic Finite Automata (NFA)", content: "A Non-Deterministic Finite Automaton (NFA) is similar to a DFA, but for a given state and input symbol, there can be zero, one, or multiple next states.\n\nAn NFA is also a 5-tuple: (Q, Σ, δ, q0, F)\nThe only difference is the transition function:\nδ: Q × Σ -> P(Q)\nwhere P(Q) is the power set of Q. This means the transition function returns a set of possible next states, rather than a single specific state.\n\nAn NFA accepts a string if there exists AT LEAST ONE valid path from the start state to an accepting state."),
        Topic(title: "4. NFA with Epsilon Transitions (ε-NFA)", content: "An ε-NFA is an NFA that allows state transitions without consuming any input symbol. This empty transition is denoted by ε (epsilon).\n\nEpsilon-closure of a state q (denoted as ε-closure(q)) is the set of all states that can be reached from q using only ε-transitions, including the state q itself.\n\nWhile ε-NFAs are easier to construct for complex regular expressions, they have the exact same computational power as standard NFAs and DFAs."),
        Topic(title: "5. Equivalence of NFA and DFA", content: "Theorem: Every NFA has an equivalent DFA that accepts the exact same language.\n\nThe algorithm used to convert an NFA to a DFA is called the 'Subset Construction' (or Power Set Construction) algorithm.\n\nSince an NFA transition can lead to a set of states, we treat sets of NFA states as single DFA states. If the NFA has 'n' states, the equivalent DFA can have up to 2^n states (the size of the power set).\n\nA resulting DFA state is an accepting state if it contains AT LEAST ONE accepting state from the original NFA."),
        Topic(title: "6. Minimization of DFA", content: "DFA minimization is the process of transforming a given DFA into an equivalent DFA with the minimum possible number of states.\n\nSteps for minimization:\n1. Remove all unreachable or inaccessible states (states that cannot be reached from the start state).\n2. Use the Table-Filling Method (Myhill-Nerode Theorem) to identify and merge distinguishable / indistinguishable states.\n- Mark pairs of states (p, q) where one is final and the other is non-final.\n- If for an input symbol 'a', the transitions from (p, q) lead to a previously marked pair, mark (p, q).\n- Merge all unmarked, equivalent pairs into single states.")
    ],
    examples: [
        Topic(title: "Example: Introduction to Languages", content: "Problem: Generate all strings of length 2 over the alphabet Σ = {0, 1}.\n\nSolution: Σ^2 = {00, 01, 10, 11}\n\nProblem: What is the language of all strings starting with '1' over Σ = {0, 1}?\n\nSolution: L = {1, 10, 11, 100, 101, 110, 111, ...}"),
        Topic(title: "Example: DFA for strings ending in '00'", content: "Alphabet: Σ = {0, 1}\nLanguage: Strings ending in 00.\nStates: q0 (start), q1 (seen one 0), q2 (seen 00 - accept state).\n\nTransitions:\n- δ(q0, 1) = q0 (stay seeking 0)\n- δ(q0, 0) = q1 (found first 0)\n- δ(q1, 1) = q0 (broken progression, restart)\n- δ(q1, 0) = q2 (found second 0!)\n- δ(q2, 0) = q2 (still ends in 00)\n- δ(q2, 1) = q0 (broken, return to start)"),
        Topic(title: "Example: DFA for Even Number of 1s", content: "Alphabet: Σ = {0, 1}\nLanguage: Strings containing an even number of '1's.\nStates: qE (Even 1s - Start & Accept state), qO (Odd 1s).\n\nTransitions:\n- δ(qE, 0) = qE (0 doesn't change 1s count)\n- δ(qE, 1) = qO (transition to odd count)\n- δ(qO, 0) = qO (0 doesn't change 1s count)\n- δ(qO, 1) = qE (transition back to even count)"),
        Topic(title: "Example: NFA for strings ending in '11'", content: "Alphabet: Σ = {0, 1}\nLanguage: Strings ending in 11.\nUnlike a DFA, an NFA can 'guess' when it is at the end of the string.\n\nStates: q0 (Start), q1, q2 (Accept)\n\nTransitions:\n- δ(q0, 0) = {q0}\n- δ(q0, 1) = {q0, q1}  // Non-deterministically guess the suffix!\n- δ(q1, 1) = {q2}\n\nNotice that δ(q1, 0) and δ(q2, 0) are empty sets (no transition defined). It instantly dies if the guess is wrong."),
        Topic(title: "Example: NFA to DFA Conversion", content: "Given the NFA for 'ending in 11' (States: q0, q1, q2).\n\nConvert using Subset Construction:\n- Start state of DFA = {q0}\n- From {q0}, on '0' -> {q0}. On '1' -> {q0, q1}.\n- New state {q0, q1}: \n  On '0' -> δ(q0,0) U δ(q1,0) = {q0} U {∅} = {q0}\n  On '1' -> δ(q0,1) U δ(q1,1) = {q0, q1} U {q2} = {q0, q1, q2} \n- New state {q0, q1, q2}:\n  On '0' -> {q0}\n  On '1' -> {q0, q1, q2}\n\nAccept states for DFA are any subsets containing NFA accept state (q2). So {q0, q1, q2} is the final accept state.")
    ],
    quizzes: [
        QuizQuestion(question: "Which of the following is an accepting 5-tuple for DFA?", options: ["(Q, Σ, δ, q0, F)", "(Q, Σ, q0, F)", "(Q, δ, q0, F)", "(Σ, δ, q0, F)"], correctOptionIndex: 0, explanation: "By definition, a Deterministic Finite Automaton is mathematically represented by 5 tuples: States (Q), Alphabet (Σ), Transition Function (δ), Start State (q0), and Accept States (F)."),
        QuizQuestion(question: "An NFA can have how many transitions for a single input alphabet from a state?", options: ["Exactly one", "Zero, one or more", "Only zero", "Exactly two"], correctOptionIndex: 1, explanation: "The 'Non-Deterministic' property means a state can branch out into multiple paths simultaneously, or completely die out (zero transitions) when reading a single character."),
        QuizQuestion(question: "What is the maximum number of states in a DFA converted from an NFA with n states?", options: ["n", "n^2", "2^n", "n!"], correctOptionIndex: 2, explanation: "Using the Subset Construction algorithm, the DFA represents the Power Set of the NFA states. The power set of 'n' elements has a maximum size of 2^n."),
        QuizQuestion(question: "Can every NFA be converted to an equivalent DFA?", options: ["Yes", "No", "Only if it doesn't have epsilon transitions", "Only for finite languages"], correctOptionIndex: 0, explanation: "Theorem: NFA and DFA have the exact same computational power. Any NFA (even with ε-transitions) can be algorithmically converted into a deterministic machine that accepts the same regular language."),
        QuizQuestion(question: "Which algorithm is used for DFA minimization?", options: ["Subset Construction", "Table-filling method", "Dijkstra's", "Kruskal's"], correctOptionIndex: 1, explanation: "The Table-Filling method (based on the Myhill-Nerode theorem) is used to find and merge indistinguishable states, minimizing the DFA.")
    ]
)
