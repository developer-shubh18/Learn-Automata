import Foundation

let unit2Content = UnitContent(
    theory: [
        Topic(title: "1. Regular Expressions (RE)", content: "A Regular Expression (RE) is a sequence of characters that form a search pattern. In Automata Theory, RE is used to denote a regular language formally and algebraically.\n\nBasic Operations of Regular Expressions:\n1. Union (denoted by + or |): R1 + R2 means choosing either the language of R1 or R2.\n2. Concatenation (denoted by .): R1 . R2 means strings of R1 followed immediately by strings of R2.\n3. Kleene Star (denoted by *): R* means zero or more occurrences of R.\n4. Kleene Plus (denoted by +): R+ means one or more occurrences of R. (Note: R+ = RR*)\n\nPrecedence of operators: Kleene Star (*) has the highest precedence, followed by concatenation (.), and then union (+)."),
        Topic(title: "2. Arden's Theorem", content: "Arden's Theorem is widely used to find the algebraic regular expression equivalent to a Finite Automaton.\n\nTheorem Statement:\nLet P and Q be two regular expressions. If P does not contain the null string (epsilon / ε), then the equation:\nR = Q + RP\nhas a unique solution given by:\nR = QP*\n\nThis theorem is used to convert a DFA/NFA mathematically into a Regular Expression by setting up algebraic equations for each state and solving them substitute-style."),
        Topic(title: "3. Pumping Lemma for Regular Languages", content: "The Pumping Lemma is a mathematical proof technique specifically used to prove that a language is NOT regular. (Note: It cannot be used to prove a language IS regular).\n\nLemma Statement:\nFor any regular language L, there exists an integer 'p' (the pumping length) such that any string 'w' in L with length |w| >= p can be divided into three parts, w = xyz, satisfying the following three conditions:\n1. |xy| <= p (The loop must occur within the first 'p' characters)\n2. |y| > 0 (The middle looping part cannot be empty)\n3. x(y^i)z is in L for all i >= 0 (You can pump 'y' zero times, once, twice, etc., and the resulting string must still be in the language).\n\nIf we can find even ONE string 'w' where the opponent cannot find a valid 'xyz' partition that satisfies all conditions, the language is NOT regular."),
        Topic(title: "4. Closure Properties of Regular Languages", content: "Closure properties state that if you apply certain operations to regular languages, the resulting language is guaranteed to also be a regular language.\n\nRegular Languages are CLOSED under:\n- Union: L1 ∪ L2 is regular.\n- Intersection: L1 ∩ L2 is regular.\n- Complement: L' is regular (swap accept/reject states in DFA).\n- Concatenation: L1 . L2 is regular.\n- Kleene Star: L* is regular.\n- Reversal: L_rev is regular.\n- Difference: L1 - L2 is regular.\n- Homomorphism and Inverse Homomorphism.\n\nUnderstanding closure properties helps quickly identify if a complex language is regular by breaking it down into operations on simple regular languages.")
    ],
    examples: [
        Topic(title: "Example: Creating Regular Expressions", content: "1. Language of all strings containing at least one 'a':\n   RE: (a+b)* a (a+b)*\n\n2. Language of all strings starting with 'a' and ending with 'b':\n   RE: a (a+b)* b\n\n3. Language of strings of even length over {0,1}:\n   RE: ((0+1)(0+1))*\n\n4. Language of strings where every '0' is immediately followed by '11':\n   RE: (1 + 011)*"),
        Topic(title: "Example: Applying Arden's Theorem", content: "Given a state machine with these equations:\nq1 = q1.0 + q2.1 + ε\nq2 = q1.1 + q2.0\n\nSolve for q2:\nq2 = q1.1 + q2.0\nUsing Arden's (R = Q + RP -> R = QP*), where R=q2, Q=q1.1, P=0:\nq2 = (q1.1)(0*)\n\nSubstitute q2 into q1:\nq1 = q1.0 + (q1.1.0*).1 + ε\nq1 = q1.(0 + 1.0*.1) + ε\nUsing Arden's again (R = Q + RP):\nQ = ε\nP = (0 + 1.0*.1)\n\nq1 = ε . (0 + 1.0*.1)*\nq1 = (0 + 10*1)*\n\nThe regular expression for reaching q1 is (0 + 10*1)*."),
        Topic(title: "Example: Using Pumping Lemma", content: "Prove L = {a^n b^n | n >= 0} is NOT regular.\n\n1. Assume L IS regular. Let 'p' be the pumping length.\n2. Choose a string w = a^p b^p. Clearly |w| = 2p >= p, and w is in L.\n3. By the lemma, w = xyz. Since |xy| <= p, both x and y MUST consist entirely of 'a's. (The 'b's don't start until position p+1).\n4. Let y = a^k, where k > 0.\n5. Let's pump it to i=2: xy^2z.\nThis new string will have (p + k) 'a's, but only 'p' 'b's.\n6. Because p+k != p, the new string xyyz is NOT in L.\n7. This contradicts the Pumping Lemma (which states all pumped strings must be in L). Therefore, our assumption was wrong. L is NOT regular.")
    ],
    quizzes: [
        QuizQuestion(question: "Which of the following operations is NOT closed for Regular Languages?", options: ["Union", "Intersection", "Complement", "None of the above (they are all closed)"], correctOptionIndex: 3, explanation: "Regular languages are fully closed under Union, Intersection, Complement, Kleene Star, and Concatenation. All of these generate another valid regular language."),
        QuizQuestion(question: "What does the Kleene Star (*) represent?", options: ["One or more occurrences", "Zero or more occurrences", "Exactly one occurrence", "Complement"], correctOptionIndex: 1, explanation: "The Kleene Star (*) means 0 or more occurrences (including the empty string ε). The Kleene Plus (+) represents 1 or more occurrences."),
        QuizQuestion(question: "Pumping Lemma is generally used for:", options: ["Proving a language is regular", "Proving a language is NOT regular", "Converting NFA to DFA", "Minimizing DFA"], correctOptionIndex: 1, explanation: "The Pumping Lemma is a proof by contradiction. It specifically proves a language is NON-regular by showing it cannot be 'pumped' infinitely without leaving the language."),
        QuizQuestion(question: "According to Arden's theorem, if R = Q + RP, then R = ?", options: ["QP*", "Q*P", "P*Q", "PQ*"], correctOptionIndex: 0, explanation: "Arden's Theorem formally states that if R = Q + RP, the unique algebraic solution is R = QP*, assuming P does not contain the empty string."),
        QuizQuestion(question: "The regular expression (0+1)* denotes:", options: ["All strings of 0s and 1s", "Only even length strings", "Only empty string", "Strings starting with 0"], correctOptionIndex: 0, explanation: "Since '+' means OR, and '*' is 0 or more occurrences, (0+1)* generates the Universal Language containing all possible binary combinations, including the empty string.")
    ]
)
