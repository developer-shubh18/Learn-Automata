import Foundation

let unit3Content = UnitContent(
    theory: [
        Topic(title: "1. Context-Free Grammars (CFG)", content: "A Context-Free Grammar is a formal grammar used to generate all possible patterns of strings in a given language. CFGs are highly powerful and are the theoretical basis for the syntax of most programming languages.\n\nA CFG consists of a 4-tuple (V, T, P, S):\n1. V: A finite set of variables (or non-terminals). These represent sets of strings.\n2. T: A finite set of terminals. These make up the actual strings in the language.\n3. P: A finite set of productions or rules. Each rule is of the exact format:\n   A -> α (Where A is a single variable, and α is a combination of variables and terminals)\n4. S: A designated start symbol (S ∈ V).\n\nThe term 'Context-Free' means that the variable 'A' on the left side of a production rule can be replaced by 'α' regardless of what context (or other symbols) surrounds 'A' in the current string."),
        Topic(title: "2. Derivation, Parse Trees & Ambiguity", content: "Derivation:\nThe process of applying CFG rules to generate a terminal string from the start symbol.\n- Left-most derivation: Always replace the leftmost variable first.\n- Right-most derivation: Always replace the rightmost variable first.\n\nParse Trees:\nA graphical representation of a derivation. The root is the start symbol, inner nodes are variables, and leaf nodes are terminals. Reading the leaves from left to right gives the final string.\n\nAmbiguity:\nA grammar is said to be Ambiguous if there exists AT LEAST ONE string in its language that can be generated using:\n1. More than one distinct left-most derivation, or\n2. More than one distinct right-most derivation, or\n3. More than one distinct parse tree.\n\nAmbiguity is dangerous in compilers because a single statement (like 'x + y * z') could be interpreted in two completely different ways mathematically."),
        Topic(title: "3. Chomsky Normal Form (CNF)", content: "A Context-Free Grammar is in Chomsky Normal Form (CNF) if all its production rules strictly follow one of two formats:\n1. A -> BC (A variable produces exactly TWO variables)\n2. A -> a (A variable produces exactly ONE terminal)\n\nAny CFG that does not generate the empty string (ε) can be algorithmically converted into CNF.\n\nBenefits of CNF:\n- Parsing algorithms (like the CYK algorithm) rely heavily on CNF.\n- If a grammar is in CNF, any string of length 'n' will take exactly '2n - 1' steps to derive."),
        Topic(title: "4. Pushdown Automata (PDA)", content: "A Pushdown Automaton (PDA) is the computational machine equivalent to a Context-Free Grammar. While Finite Automata can only handle regular languages (like strings ending in '00'), they fail on languages that require counting or infinite memory (like matching parentheses or a^n b^n).\n\nPDA = Finite State Machine + A Stack Memory.\n\nA PDA is a 7-tuple: (Q, Σ, Γ, δ, q0, Z0, F)\n1. Q: States\n2. Σ: Input alphabet\n3. Γ: Stack alphabet (symbols that can be pushed onto the stack)\n4. δ: Transition function (takes current state, input symbol, and top stack symbol, and returns next state and stack operation)\n5. q0: Start state\n6. Z0: Initial stack symbol (denotes an empty stack)\n7. F: Accept states\n\nWhen a PDA reads an input, it can decide to push symbols onto the stack, pop symbols off, or ignore the stack entirely."),
        Topic(title: "5. Deterministic vs Non-Deterministic PDA", content: "In Finite Automata, NFAs and DFAs have the exact same mathematical power. However, this is NOT true for Pushdown Automata.\n\nA Non-Deterministic PDA (NPDA) is strictly MORE powerful than a Deterministic PDA (DPDA).\n\nWhy?\nBecause of languages like palindromes. In an NPDA, the machine can 'guess' where the middle of the string is, and switch from pushing to popping. A DPDA cannot guess; it must know deterministically when to swap. Therefore, DPDAs can only accept 'Deterministic Context-Free Languages' (which form the basis of LR parsers in compilers), while NPDAs accept all Context-Free Languages.")
    ],
    examples: [
        Topic(title: "Example: CFG for Parentheses Matching", content: "Language: All properly matched strings of parentheses.\n\nGrammar Rules:\nS -> (S)    (Wrap an existing matched pair)\nS -> SS     (Put two matched pairs side-by-side)\nS -> ε      (Empty string is technically matched)\n\nDeriving '(())':\nS => (S) => ((S)) => ((ε)) => (())"),
        Topic(title: "Example: Showing Ambiguity", content: "Grammar: E -> E + E | E * E | id\n\nString to generate: 'id + id * id'\n\nParse Tree 1 (Addition first):\nE => E * E => (E + E) * E => id + id * id\n(Here, addition is performed before multiplication)\n\nParse Tree 2 (Multiplication first):\nE => E + E => E + (E * E) => id + id * id\n(Here, multiplication is tied correctly)\n\nBecause the same string generated two distinct trees, this grammar is ambiguous."),
        Topic(title: "Example: PDA logic for a^n b^n", content: "Language: a^n b^n (n >= 0)\nInput: aabb\n\nLogic flow:\n1. Start in State q0. Stack is [Z0].\n2. Read 'a'. Push 'A' to stack. Stack is [A, Z0].\n3. Read 'a'. Push 'A'. Stack is [A, A, Z0].\n4. Read 'b'. We are now changing state to q1. Pop an 'A'. Stack is [A, Z0].\n5. Read 'b'. Pop an 'A'. Stack is [Z0].\n6. Input is empty. Top of stack is Z0. Accept!"),
        Topic(title: "Example: Convert to CNF", content: "Original Rule: S -> aAbB\n\nStep 1: Replace terminals with new variables.\nX_a -> a\nX_b -> b\nS -> X_a A X_b B\n\nStep 2: Break long variables into pairs.\nS -> X_a Y1\nY1 -> A Y2\nY2 -> X_b B\n\nNow everything is strictly A -> BC or A -> a!")
    ],
    quizzes: [
        QuizQuestion(question: "A grammar is ambiguous if it has:", options: ["More than one production rule", "More than one derivation tree for a string", "No epsilon transitions", "Left recursion"], correctOptionIndex: 1, explanation: "Ambiguity means a grammar is mathematically confusing. It produces at least one string that has two entirely different derivation trees (e.g. interpreting '1+2*3' multiple ways)."),
        QuizQuestion(question: "In Chomsky Normal Form, a production is of the form:", options: ["A -> BC or A -> a", "A -> aB or A -> a", "A -> B or A -> e", "A -> ABC"], correctOptionIndex: 0, explanation: "Chomsky Normal Form strictly requires productions to yield exactly two variables (A -> BC) or exactly one terminal (A -> a)."),
        QuizQuestion(question: "What memory structure does a Pushdown Automaton use?", options: ["Queue", "Stack", "Linked List", "Tape"], correctOptionIndex: 1, explanation: "A PDA uses a LIFO (Last-In-First-Out) Stack memory structure. This allows it to count indefinitely (like matching an endless number of parentheses)."),
        QuizQuestion(question: "Are NPDA and DPDA equivalent in power?", options: ["Yes", "No", "Only for finite sets", "Only for regular sets"], correctOptionIndex: 1, explanation: "Unlike Finite Automata, non-deterministic PDAs are strictly more powerful than deterministic PDAs. DPDAs cannot 'guess' string midpoints for Context-Free palindromes."),
        QuizQuestion(question: "Context-Free Languages are closed under:", options: ["Intersection", "Complement", "Union", "None of the above"], correctOptionIndex: 2, explanation: "CFLs are closed under Union, Concatenation, and Kleene Star. They are surprisingly NOT closed under Intersection or Complement.")
    ]
)
